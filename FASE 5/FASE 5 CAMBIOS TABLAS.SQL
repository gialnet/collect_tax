/* TABLAS ANTIGUAS */
CREATE TABLE NEXT_LEVANTA_CUENTAS (
	IDEXPE   	INTEGER NOT NULL,
	ZONA		CHAR(2) NOT NULL,
	LOTE		CHAR(10) NOT NULL,
	NIF 		CHAR(10),
	LEVANTADO 	CHAR(1) DEFAULT 'N',
	F_ENTRADA 	DATE DEFAULT SYSDATE,
	-- Indica el tipo de levantamiento por defecto T de total, P de parcial
	TIPO		CHAR(1) DEFAULT 'T',

	PRIMARY KEY(IDEXPE),

	CONSTRAINT NELECUEXPE
	FOREIGN KEY (IDEXPE)
	REFERENCES EXPEDIENTES (ID),

	CONSTRAINT NELECUHEADLOTE
	FOREIGN KEY (ZONA,LOTE)
	REFERENCES HEAD_LOTES_CUENTAS(ZONA,LOTE)
	ON DELETE CASCADE
);

CREATE TABLE CUENTAS_A_LEVANTAR(
	ID 		INTEGER NOT NULL,
	ENTIDAD 	CHAR(4),
   	OFICINA 	CHAR(4),
   	DC 		CHAR(2),
   	CUENTA 	CHAR(10),
	RETENIDO	FLOAT DEFAULT 0,
    -- En casos de levantamientos parciales el importe de la nueva retención
    -- es decir el importe aminorado despues del ingreso o la baja
	NUEVARETEN	FLOAT DEFAULT 0,
	F_RETENCION DATE,

	CONSTRAINT CUALEVANELECU
	FOREIGN KEY (ID)
	REFERENCES NEXT_LEVANTA_CUENTAS (IDEXPE)
	ON DELETE CASCADE
);


/* CAMBIOS EN LAS TABLAS */

ALTER TABLE NEXT_LEVANTA_CUENTAS ADD ID INTEGER;
ALTER TABLE NEXT_LEVANTA_CUENTAS ADD F_ENVIO_FASE5 DATE;

ALTER TABLE CUENTAS_A_LEVANTAR ADD IDEXPE INTEGER;
UPDATE CUENTAS_A_LEVANTAR SET IDEXPE=ID;
ALTER TABLE CUENTAS_A_LEVANTAR MODIFY IDEXPE NOT NULL;
ALTER TABLE CUENTAS_A_LEVANTAR DROP CONSTRAINT CUALEVANELECU;

ALTER TABLE NEXT_LEVANTA_CUENTAS DROP PRIMARY KEY;

CREATE OR REPLACE PROCEDURE PONID AS
	I INTEGER;
	CURSOR C1 IS SELECT IDEXPE FROM NEXT_LEVANTA_CUENTAS
	ORDER BY F_ENTRADA;
BEGIN
	I:=1;
	FOR v1 IN C1
	LOOP
		UPDATE NEXT_LEVANTA_CUENTAS SET ID=I WHERE IDEXPE=v1.IDEXPE;
		I:=I+1;
	END LOOP;	
END;

EXECUTE PONID;
DROP PROCEDURE PONID;

ALTER TABLE NEXT_LEVANTA_CUENTAS ADD PRIMARY KEY(ID);
ALTER TABLE NEXT_LEVANTA_CUENTAS MODIFY ID NOT NULL;


CREATE SEQUENCE GENNEXTLEVANTA INCREMENT BY 1 START WITH xxx; xxx=I;
CREATE PUBLIC SYNONYM GENNEXTLEVANTA FOR .GENNEXTLEVANTA;

CREATE OR REPLACE TRIGGER T_INS_NEXT_LEVANTA
BEFORE INSERT ON NEXT_LEVANTA_CUENTAS
FOR EACH ROW
BEGIN
   SELECT GENNEXTLEVANTA.NEXTVAL INTO :NEW.ID FROM DUAL;   
END;
/


UPDATE CUENTAS_A_LEVANTAR SET ID=(SELECT ID FROM NEXT_LEVANTA_CUENTAS
WHERE IDEXPE=CUENTAS_A_LEVANTAR.IDEXPE);

ALTER TABLE CUENTAS_A_LEVANTAR ADD CONSTRAINT CUALEVANELECU
	FOREIGN KEY (ID)
	REFERENCES NEXT_LEVANTA_CUENTAS (ID)
	ON DELETE CASCADE;
	
ALTER TABLE CUENTAS_A_LEVANTAR ADD DEUDA_A_EMBARGAR FLOAT DEFAULT 0;
UPDATE CUENTAS_A_LEVANTAR SET DEUDA_A_EMBARGAR=(SELECT DEUDA_A_EMBARGAR
FROM CUENTAS_LOTES WHERE IDEXPE=CUENTAS_A_LEVANTAR.IDEXPE AND ENTIDAD=
CUENTAS_A_LEVANTAR.ENTIDAD AND OFICINA=CUENTAS_A_LEVANTAR.OFICINA AND
DC=CUENTAS_A_LEVANTAR.DC AND CUENTA=CUENTAS_A_LEVANTAR.CUENTA);


/* procedimiento que borrar de cuentas_lotes las cuentas a las que se les ha hecho 
un levantamiento total (nuevareten=0) pero siguen en cuentas_lotes por error en 
los antiguos procedimientos */

CREATE OR REPLACE PROCEDURE BORRARCUENTASLOTES AS
	mID	  INTEGER;
	mZONA CHAR(2);
	mLOTE CHAR(10);
	mFECHA DATE;
	CURSOR C1 IS SELECT * FROM CUENTAS_A_LEVANTAR WHERE NUEVARETEN=0;
BEGIN
	FOR v1 IN C1
	LOOP
	
	   BEGIN
	
	   	SELECT ID,ZONA,LOTE,F_DILIGENCIA INTO mID,mZONA,mLOTE,mFECHA
	   	FROM CUENTAS_LOTES
	   	WHERE IDEXPE=v1.IDEXPE AND ENTIDAD=v1.ENTIDAD AND OFICINA=v1.OFICINA AND 
	   		 DC=v1.DC AND CUENTA=v1.CUENTA AND DEUDA_A_EMBARGAR=v1.DEUDA_A_EMBARGAR;
	   		 
	    EXCEPTION
	    	WHEN NO_DATA_FOUND THEN
	    		mID:=0;
	   END;
	   	
	   IF (mID>0) THEN	 
	   		-- borramos la cuenta y comprobamos el estado del embargo		    		    
	   		DELETE FROM CUENTAS_LOTES WHERE ID=mID;
   			
       		CUENTAS_CONTROL_ESTADOS(v1.IDEXPE,v1.Entidad,v1.Oficina,mZONA,mLOTE,mFECHA);		    
      END IF;
      
	END LOOP;
END;
/

EXECUTE BORRARCUENTASLOTES;
DROP PROCEDURE BORRARCUENTASLOTES;

-- cuando se repone un pago de un expediente, suspensión o anulación
-- se ha de borrar el levantamiento que se generó, pero sólo ése, ya
-- que puede haber levantamientos anteriores que deben continuar en
-- la tabla next_levanta_cuentas
CREATE TABLE BORRA_LEVANTAMIENTOS(
	IDEXPE	INTEGER NOT NULL,
	ID		INTEGER NOT NULL
)TABLESPACE RECA;
CREATE PUBLIC SYNONYM BORRA_LEVANTAMIENTOS FOR .BORRA_LEVANTAMIENTOS;


/* NUEVAS TABLAS */
CREATE TABLE NEXT_LEVANTA_CUENTAS (
	ID			INTEGER NOT NULL,
	IDEXPE   	INTEGER NOT NULL,
	ZONA		CHAR(2) NOT NULL,
	LOTE		CHAR(10) NOT NULL,
	NIF 		CHAR(10),
	LEVANTADO 	CHAR(1) DEFAULT 'N',
	F_ENTRADA 	DATE DEFAULT SYSDATE,
	-- Indica el tipo de levantamiento por defecto T de total, P de parcial
	TIPO		CHAR(1) DEFAULT 'T',
	F_ENVIO_FASE5 DATE,
	PRIMARY KEY(ID),
	CONSTRAINT NELECUEXPE
	FOREIGN KEY (IDEXPE)
	REFERENCES EXPEDIENTES (ID),
	CONSTRAINT NELECUHEADLOTE
	FOREIGN KEY (ZONA,LOTE)
	REFERENCES HEAD_LOTES_CUENTAS(ZONA,LOTE)
	ON DELETE CASCADE
);

CREATE TABLE CUENTAS_A_LEVANTAR(
	ID 		INTEGER NOT NULL,
	IDEXPE	INTEGER NOT NULL,
	ENTIDAD 	CHAR(4),
   	OFICINA 	CHAR(4),
   	DC 		CHAR(2),
   	CUENTA 	CHAR(10),
   	DEUDA_A_EMBARGAR FLOAT DEFAULT 0,
	RETENIDO	FLOAT DEFAULT 0,
    -- En casos de levantamientos parciales el importe de la nueva retención
    -- es decir el importe aminorado despues del ingreso o la baja
	NUEVARETEN	FLOAT DEFAULT 0,
	F_RETENCION DATE,	
	CONSTRAINT CUALEVANELECU
	FOREIGN KEY (ID)
	REFERENCES NEXT_LEVANTA_CUENTAS (ID)
	ON DELETE CASCADE
);

